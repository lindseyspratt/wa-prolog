let util = require('utilities');
/*
file_to_bytes(X, Y) :-
    load_buffer(X), // $call_foreign load_buffer/1, 1
    get_byte(B),    // $call_foreign get_byte/1, 1
    file_to_bytes1(B, Y).   // $execute file_to_bytes1/2

file_to_bytes1(-1, []) :- !.    // $neck_cut
file_to_bytes1(B, [B|T]) :-
    get_byte(B2),       // $call_foreign get_byte/1, 2
    file_to_bytes1(B2, T).      // $execute file_to_bytes1/2

compile:

file_to_bytes/2:
    $allocate
    ;; X:A1, Y:A2
    ;; load_buffer can be called immediately, A1 from head already has X
    $get_variable 1, 1, 2   ;; get_variable Y1,A2
    $call_foreign load_buffer/1
    $put_variable 1, 2, 1    ;; put_variable Y1, A1
    $call_foreign get_byte/1
    $put_value 1, 2, 1      ;; should this be put_unsafe_value?
    $put_value 1, 1, 2      ;; should this be put_unsafe_value?
    $deallocate
    $execute file_to_bytes1/2

file_to_bytes1/2:
    $try_me_else L1
    $get_integer -1, 1
    $get_atom   '[]', 2
    $neck_cut
    $proceed
L1: $trust_me
    $allocate
    $get_variable 1, 1, 1
    $put_variable 1, 2, 3
    $get_list 2
    $unify_variable 1
    $unify_variable 3
    $put_variable 1, 3, 1
    $call_foreign get_byte/1
    $put_value 1, 3, 1
    $put_value 1, 2, 2
    $deallocate
    $execute file_to_bytes1/2

 */

// file_to_bytes(X, Y) :-
//     load_buffer(X), // $call_foreign load_buffer/1, 1
//     get_byte(B),    // $call_foreign get_byte/1, 1
//     file_to_bytes1(B, Y).   // $execute file_to_bytes1/2

function createFileToBytesProgram () {
    return [
        util.opCodes.allocate,
        util.opCodes.get_variable, 1, 1, 2,
        util.opCodes.call_foreign, util.lookupIndicator("load_buffer",1),
        util.opCodes.put_variable, 1, 2, 1,
        util.opCodes.call_foreign, util.lookupIndicator("get_byte",1),
        util.opCodes.put_value, 1, 2, 1,
        util.opCodes.put_value, 1, 1, 2,
        util.opCodes.deallocate,
        util.opCodes.execute, util.lookupIndicator("file_to_bytes1", 2)
    ];
}

// file_to_bytes1(-1, []) :- !.    // $neck_cut
// file_to_bytes1(B, [B|T]) :-
//     get_byte(B2),       // $call_foreign get_byte/1, 2
//     file_to_bytes1(B2, T).      // $execute file_to_bytes1/2

function createFileToBytes1Program () {
    return util.process_labels([
        util.opCodes.try_me_else, {ref: 'C2a'},

        util.opCodes.get_integer, -1, 1,
        util.opCodes.get_atom, util.lookup_atom("[]"), 2,
        util.opCodes.neck_cut,
        util.opCodes.proceed,

        {label: 'C2a'},
        util.opCodes.trust_me,
        util.opCodes.allocate,
        util.opCodes.get_variable, 1, 1, 1,
        util.opCodes.put_variable, 1, 2, 3,
        util.opCodes.get_list, 2,
        util.opCodes.unify_value, 1,
        util.opCodes.unify_value, 3,
        util.opCodes.put_variable, 1, 3, 1,
        util.opCodes.call_foreign, util.lookupIndicator("get_byte",1),
        util.opCodes.put_unsafe_value, 3, 1,
        util.opCodes.put_unsafe_value, 2, 2,
        util.opCodes.deallocate,
        util.opCodes.execute, util.lookupIndicator("file_to_bytes1", 2),
    ]);
}

function createFileToBytesQuery() {
    return [
        util.opCodes.put_atom, util.lookup_atom('node_modules/ftbShortTest.txt'), 1,
        util.opCodes.execute, util.lookupIndicator("file_to_bytes", 2),
        util.opCodes.proceed
    ];
}

module.exports.createFileToBytesProgram = createFileToBytesProgram;
module.exports.createFileToBytes1Program = createFileToBytes1Program;
module.exports.createFileToBytesQuery = createFileToBytesQuery;