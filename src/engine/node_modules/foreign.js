const fs = require('fs');
let hostData;

let wam = {};


let buffer = [];

// load url into a buffer in NodeJS.
function loadBuffer(url) {
    if(typeof document !== 'undefined') {
        buffer = new Uint8Array([30]);
    } else {
        buffer = fs.readFileSync(url);
    }
}

function getByte() {
    if(buffer.length > 0) {
        let byte = buffer[0];
        buffer = buffer.subarray(1);
        return byte;
    } else {
        return -1; // end of buffer.
    }
}

function setWAM(paramWAM) {
    wam = paramWAM;
}

function setHostData(paramHostData) {
    hostData = paramHostData;
}

function predicate_load_buffer(urlID) {
    if( wam_termTag(urlID) !== wam_TAG_ATM()){
        throw 'invalid term. expected atom. tag = ' + wam_termTag(urlID) + ', val = ' + wam_termVal(urlID);
    }

    loadBuffer(hostData.find_atom(wam_termVal(urlID)));
}

function predicate_get_byte(value) {
    let byte = getByte();
    // put 'byte' on the heap at the top.
    // This location is recorded in byteAddr.
    let x = wam_tagInteger(byte);
    let xt = wam_termTag(x);
    let xv = wam_termValInt(x);

    let byteAddr = wam_set_constant_result(wam_TAG_INT(), byte);

    wam_unifyTerms(value, byteAddr); // wam_unifyTerms sets wam.$fail == true if unify/2 fails.
}

function wam_termTag(term) {
    return wam.instance.exports.termTag(term);
}

function wam_termVal(term) {
    return wam.instance.exports.termVal(term);
}

function wam_termValInt(term) {
    return wam.instance.exports.termValInt(term);
}

function wam_TAG_ATM() {
    return wam.instance.exports.TAG_ATM.valueOf();
}

function wam_TAG_INT() {
    return wam.instance.exports.TAG_INT.valueOf();
}

function wam_unifyTerms(term1, term2) {
    wam.instance.exports.unifyTerms(term1, term2);
}

function wam_tagInteger(integer) {
    return wam.instance.exports.tagInteger(integer);
}

function wam_set_constant_result(type, value) {
    return wam.instance.exports.set_constant_result(type, value);
}

module.exports.setHostData = setHostData;
module.exports.setWAM = setWAM;
module.exports.predicate_load_buffer = predicate_load_buffer;
module.exports.predicate_get_byte = predicate_get_byte;


// get_byte(Stream, Byte) :-
//     stream_read(Stream, Read),
//     callx(Read, Byte).
//
// callx(pred, a1, a2, ...)
//
// compiles to
//     put arity in a1
//     prep arg2 to a2
//     ...
//     prep argX to aX
//     prep arg1 to aX+1
//     put pred in aX+2
//     callx N
//
//
//     get_variable 1, 1, 2    ;; Byte/A2 to Y1. A1 left in place.
//     put_variable 1, 2, 2    ;; create var for Read in Y2 and A2.
//     call stream_read/2, 1
//     put_integer 1, 2        ;; put arity 1 in A1
//     put_value 1, 1, 2       ;; put value in Y1 to A2 (A1+1)
//     put_value 1, 2, 3       ;; put value in Y2 to A3 (A1+2)
//     executex
//
//
// call(P ; Q) :-
//     call(P).
// call(P ; Q) :-
//     call(Q).
// call((P,Q)) :-
//     call(P),
//     call(Q).
// call(P) :-
//     P =.. [F|As],
//     callXL(F, As).
//
// call(P, As) :-
//     P =.. [F|PAs],
//     append(PAs, As, FAs),
//     callXL(F, FAs).








