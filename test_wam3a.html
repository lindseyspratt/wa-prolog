<html lang="">
<head>
    <title>Web Assembly Wam Tests</title>
<script>
    let table = new WebAssembly.Table({initial: 100, element: "anyfunc"});
    let memory = new WebAssembly.Memory({initial: 1});
    let atable = [];
    let code = [];
    let indicators = [];
    let programs = [];

    const MAX_REGISTER = 256;
    const PDL_START = (MAX_REGISTER+1) * 4;
    const MAX_PDL = 256;
    const MIN_STACK = MAX_REGISTER + MAX_PDL + 1;
    const STACK_START = (MIN_STACK*4);
    const MAX_STACK = 128;
    const MIN_TRAIL = MAX_REGISTER + MAX_PDL + MAX_STACK + 1;
    const TRAIL_START = (MIN_TRAIL*4);
    const MAX_TRAIL = 128;
    const MIN_HEAP = MAX_REGISTER + MAX_PDL + MAX_STACK + MAX_TRAIL + 1;
    const HEAP_START = (MIN_HEAP*4);

    let importObject = {js:
            {mem: memory,
                table: table,
                maxRegister: MAX_REGISTER,
                pdlStart: PDL_START,
                maxPDL: MAX_PDL,
                minStack: MIN_STACK,
                stackStart: STACK_START,
                maxStack: MAX_STACK,
                minTrail: MIN_TRAIL,
                trailStart: TRAIL_START,
                maxTrail: MAX_TRAIL,
                minHeap: MIN_HEAP,
                heapStart: HEAP_START,
            lookupAtom: lookupAtomWA,
            getCode: getCodeWA,
            setCode: setCodeWA,
            getIndicatorArity: getIndicatorArityWA,
            traceInstLog0: traceInstLog0,
            traceInstLog1: traceInstLog1,
            traceInstLog2: traceInstLog2,
            traceInstLog3: traceInstLog3,
                traceStoreZero: traceStoreZero,
                traceDerefZero: traceDerefZero,
                traceStoreTrailToReg: traceStoreTrailToReg,
            }};

    function lookupAtomWA(start, length){
        var bytes = new Uint8Array(memory.buffer, start, length);
        var string = new TextDecoder('utf8').decode(bytes);
        return lookup_atom(string);
    }

    function getCodeWA(codeOfst) {
        return code[codeOfst];
    }

    function setCodeWA(codeOfst) {
        code = programs[codeOfst];
    }

    function getIndicatorArityWA(indicator) {
        return indicators[indicator][1];
    }

    function lookup_atom(name)
    {
        if(typeof name !== 'string') {
            throw 'invalid lookup_atom. name must have type of string, but is ' + typeof name + '. name = ' + name;
        }

        var i;
        for (i = 0; i < atable.length; i++)
        {
            if (atable[i] === name)
                return i;
        }
        i = atable.length;
        atable[i] = name;
        return i;
    }

    function find_atom(internalID) {
        return atable[internalID];
    }

    function lookupIndicator(name, arity) {
        let nameID = lookup_atom(name);

        let i;
        for (i = 0; i < indicators.length; i++) {
            if (indicators[i][0] === nameID
                && indicators[i][1] === arity) {
                console.log(name + '/' + arity + ' found ' + i);
                return i;
            }
        }
        i = indicators.length;
        indicators[i] = [nameID, arity];
        console.log(name + '/' + arity + ' created ' + i);
        return i;
    }

    function process_labels(program) {
        let map = {};
        let result = [];
        let j = 0;
        // find labels
        for(let i = 0;i < program.length; i++) {
            if(typeof program[i] === 'object') {
                if(program[i].label) {
                    map[program[i].label] = j+1;
                    continue; // skip to next word after label word.
                }
            }
            j++;
            result[j] = program[i];
        }

        // replace label references
        for(let k = 0;k < result.length; k++) {
            if(typeof result[k] === 'object') {
                if(result[k].ref) {
                    result[k] = map[result[k].ref];
                }
            }
        }

        return result;
    }
    let opCodes;

    function initialize_op_codes(obj) {
        opCodes = {};
        opCodes.nop = obj.instance.exports.nop_opcode();
        opCodes.put_structure = obj.instance.exports.put_structure_opcode();
        opCodes.get_structure = obj.instance.exports.get_structure_opcode();
        opCodes.set_variable = obj.instance.exports.set_variable_opcode();
        opCodes.put_variable = obj.instance.exports.put_variable_opcode();
        opCodes.get_variable = obj.instance.exports.get_variable_opcode();
        opCodes.set_value = obj.instance.exports.set_value_opcode();
        opCodes.put_value = obj.instance.exports.put_value_opcode();
        opCodes.get_value = obj.instance.exports.get_value_opcode();
        opCodes.unify_variable = obj.instance.exports.unify_variable_opcode();
        opCodes.unify_value = obj.instance.exports.unify_value_opcode();
        opCodes.call = obj.instance.exports.call_opcode();
        opCodes.proceed = obj.instance.exports.proceed_opcode();
        opCodes.allocate = obj.instance.exports.allocate_opcode();
        opCodes.deallocate = obj.instance.exports.deallocate_opcode();
        opCodes.try_me_else = obj.instance.exports.try_me_else_opcode();
        opCodes.retry_me_else = obj.instance.exports.retry_me_else_opcode();
        opCodes.trust_me = obj.instance.exports.trust_me_opcode();
        opCodes.put_constant = obj.instance.exports.put_constant_opcode();
        opCodes.get_constant = obj.instance.exports.get_constant_opcode();
        opCodes.set_constant = obj.instance.exports.set_constant_opcode();
        opCodes.unify_constant = obj.instance.exports.unify_constant_opcode();
        opCodes.put_list = obj.instance.exports.put_list_opcode();
        opCodes.get_list = obj.instance.exports.get_list_opcode();
        opCodes.set_void = obj.instance.exports.set_void_opcode();
        opCodes.unify_void = obj.instance.exports.unify_void_opcode();
    }

    function getOpCodeName(opCode) {
        let keys = Object.keys(opCodes);
        for(let i = 0;i < keys.length;i++) {
            let key = keys[i];
            if(opCodes[key] === opCode) {
                return key;
            }
        }
        return 'undefined';
    }

    function create_program_4_4_p_2_a() {
        // p(X, a).
        // p(b, X).
        // p(X, Y) :- p(X,a), p(b,Y).
        return process_labels([
            opCodes.try_me_else, {ref: 'L1'},                   // try_me_else, L1
            opCodes.get_variable, 0, 3, 1,                      // get_variable X3, A1
            opCodes.get_constant, lookup_atom("a"), 2,          // get_constant a, A2
            opCodes.proceed,                                    // proceed
            {label: 'L1'},
            opCodes.retry_me_else, {ref: 'L2'},                 // try_me_else, L2
            opCodes.get_constant, lookup_atom("b"), 1,          // get_constant b, A1
            opCodes.get_variable, 0, 3, 2,                      // get_variable X3, A2
            opCodes.proceed,                                    // proceed
            {label: 'L2'},
            opCodes.trust_me,
            opCodes.allocate, 1,                                // allocate, 1
            opCodes.get_variable, 0, 3, 1,                      // get_variable X3, A1
            opCodes.put_value, 0, 3, 1,                         // put_value X3, A1
            opCodes.put_constant, lookup_atom("a"), 2,          // put_constant a, A2
            opCodes.call, lookupIndicator("p", 2),              // call p/2
            opCodes.put_constant, lookup_atom("b"), 1,          // put_constant b, A1
            opCodes.put_value, 1, 1, 2,                         // put_value Y1, A2
            opCodes.call, lookupIndicator("p", 2),              // call p/2
            opCodes.deallocate                                  // deallocate
        ]);
    }

    function create_query_4_4_a() {
        // ?- p(c,d).
        return [
            opCodes.put_constant, lookup_atom("c"), 1,          // put_constant, c,A1
            opCodes.put_constant, lookup_atom("d"), 2,          // put_constant, d,A2
            opCodes.call, lookupIndicator("p", 2)               // call p/2
        ];
    }

    function test_query_4_4_a() {

        fetch('build/wam/language3a.wasm').then(response =>
            response.arrayBuffer()
        ).then(bytes =>
            WebAssembly.instantiate(bytes, importObject)
        ).then(obj => {
            initialize_op_codes(obj);

            programs = [];
            programs[lookupIndicator("p", 2)] = create_program_4_4_p_2_a();

            code = create_query_4_4_a();
            let i32Initial = new Uint32Array(memory.buffer);
            for(let i = 0; i < MIN_HEAP + 100;i++) {
                i32Initial[i] = 0;
            }

            obj.instance.exports.run(0);
            let i32 = new Uint32Array(memory.buffer);

            display_results('test query4_4a', i32, MIN_HEAP, 16);
        });
    }

    function create_query_5_4() {
        // ?- p(Z, [Z,W], f(W)).
        return [
            opCodes.put_list, 5,    // put_list X5
            opCodes.set_variable, 6, // set_variable X6
            opCodes.set_constant, lookup_atom("[]"), // set_constant []
            opCodes.put_variable, 0, 4, 1, // put_variable X4, A1
            opCodes.put_list, 2, // put_list A2
            opCodes.set_value, 4, // set_value X4
            opCodes.set_value, 5, // set_value X5
            opCodes.put_structure, lookupIndicator("f", 1), 3, // put_structure f/3, A3
            opCodes.set_value, 6, // set_value X6
            opCodes.call, lookupIndicator("p", 3)
        ];
    }

    function create_program_5_5() {
        // p(f(X), [Y, f(a)], Y).
        return [
            opCodes.get_structure, lookupIndicator("f", 1), 1,  // get_structure f/1, A1
            opCodes.unify_variable, 4,                          // unify_variable X4
            opCodes.get_list, 2,                                // get_list A2
            opCodes.unify_variable, 5,                          // unify_variable X5
            opCodes.unify_variable, 6,                          // unify_variable X6
            opCodes.get_value, 5, 3,                            // get_value X5,A3
            opCodes.get_list, 6,                                // get_list X6
            opCodes.unify_variable, 7,                          // unify_variable X7
            opCodes.unify_constant, lookup_atom("[]"),          // unify_constant []
            opCodes.get_structure, lookupIndicator("f",1), 7,   // get_structure f/1,X7
            opCodes.unify_constant, lookup_atom("a"),           // unify_constant a
            opCodes.proceed                                     // proceed
        ];
    }

    function test_query_5_4() {

        fetch('build/wam/language3a.wasm').then(response =>
            response.arrayBuffer()
        ).then(bytes =>
            WebAssembly.instantiate(bytes, importObject)
        ).then(obj => {
            initialize_op_codes(obj);

            programs = [];
            programs[lookupIndicator("p", 3)] = create_program_5_5();

            code = create_query_5_4();
            let i32Initial = new Uint32Array(memory.buffer);
            for(let i = 0; i < MIN_HEAP + 100;i++) {
                i32Initial[i] = 0;
            }

            obj.instance.exports.run(0);
            let i32 = new Uint32Array(memory.buffer);

            display_results('test query5_4', i32, MIN_HEAP, 16);
        });
    }

    function create_query_5_7() {
        // ?- p(X,Y,Z).
        return [
            opCodes.put_variable, 0, 4, 1, // put_variable X4, A1
            opCodes.put_variable, 0, 5, 2, // put_variable X5, A2
            opCodes.put_variable, 0, 6, 3, // put_variable X6, A3
            opCodes.call, lookupIndicator("p", 3)
        ];
    }

    function create_program_5_7() {
        // p(_, g(X), f(_, Y, _)).
        return [
            opCodes.get_structure, lookupIndicator("g", 1), 2,  // get_structure g/1, A2
            opCodes.unify_void, 1,                              // unify_void 1
            opCodes.get_structure, lookupIndicator("f", 3), 3,  // get_structure f/3, A3
            opCodes.unify_void, 3,                              // unify_void 3
            opCodes.proceed                                     // proceed
        ];
    }

    function test_query_5_7() {

        fetch('build/wam/language3a.wasm').then(response =>
            response.arrayBuffer()
        ).then(bytes =>
            WebAssembly.instantiate(bytes, importObject)
        ).then(obj => {
            initialize_op_codes(obj);

            programs = [];
            programs[lookupIndicator("p", 3)] = create_program_5_7();

            code = create_query_5_7();
            let i32Initial = new Uint32Array(memory.buffer);
            for(let i = 0; i < MIN_HEAP + 100;i++) {
                i32Initial[i] = 0;
            }

            obj.instance.exports.run(0);
            let i32 = new Uint32Array(memory.buffer);

            display_results('test query5_7', i32, MIN_HEAP, 16);
        });
    }

    function display_results(test, results, startingWord, length) {
        let element1 = document.getElementById('testName');
        element1.innerText = 'Test: ' + test;
        let element2 = document.getElementById('result');
        element2.innerText = 'startingWord=' + startingWord + ': ' + JSON.stringify(results.slice(startingWord, startingWord+length));
        let element3 = document.getElementById('resultInterpretationRegisters');
        element3.innerText = 'registers: ' + interpret_memory(results, 1, 16);
        let element4 = document.getElementById('resultInterpretationHeap');
        element4.innerText = 'heap: ' + interpret_memory(results, startingWord);
    }
    function interpret_memory(results, startingWord, explicitLength) {
        let output = '';
        let i = startingWord;
        while(i < results.length) {
            let info = interpret_memory_item(results, i);
            if((!explicitLength && info.string === '_0')||(explicitLength && i >= explicitLength)) {
                // fake variable reference
                break;
            }
            output += i + ': ' + info.string + '; ';
            i = info.nextItemOfst;
        }
        return output;
    }
    function interpret_memory_item(results, itemOfst) {
        let word = results[itemOfst];
        let tag = get_tag(word);
        switch(tag) {
            case TAG_REF: //var/REFerence
            {
                let string = '_' + get_val(word);
                if(string === '_0') {
                    return {string: string, nextItemOfst: itemOfst+1};
                }
                let term = results[get_val(word)];
                if(term === 0) {
                    string += "->_0";
                } else if(term !== word) {
                    let stringInfo = interpret_memory_item(results, get_val(word));
                    string = "->" + stringInfo.string;
                }
                return {string: string, nextItemOfst: itemOfst+1}; // variable represented by '_N' where N is an arbitrary integer.
            }
            case TAG_PRE: //PREdicate = f/n
            {
                let indicator = get_val(word);
                let result = '';
                result += '{' + itemOfst + '} ';
                return interpret_memory_structure(results, result, indicator, 0, itemOfst);
            }
            case TAG_STR: //STRucture
            {
                // STR value is address of indicator word, which is immediately followed by arity(indicator) argument words.
                // Each argument word is a (tagged) term word
                // structure = f(a1, ..., an)
                // The indicator word may directly follow the 'structure' word, or it may be elsewhere.
                // If it is directly after the structure word, then the intrepret_memory processing will skip
                // to the end of the structure to continue to the next item.
                let result = '';
                let structureWordOfst = get_val(word);
                result += '{' + structureWordOfst + '} ';
                let indicatorTerm = results[structureWordOfst];
                if(get_tag(indicatorTerm) !== TAG_PRE){
                    return {string: 'unrecognized: ' + word + ' (tag = ' + get_tag(indicatorTerm) + ', val = ' + get_val(indicatorTerm) + ') at ' + structureWordOfst,
                        nextItemOfst: itemOfst+1};
                }
                return interpret_memory_structure(results, result, get_val(indicatorTerm), structureWordOfst, itemOfst);
            }
            case TAG_LIS: //LISt
            {
                // LIS value is address of head term word, which is immediately followed by tail term word.
                // list = [head|tail]
                // The head word may directly follow the 'list' word, or it may be elsewhere.
                // If it is directly after the list word, then the intrepret_memory processing will skip
                // to the end of the list to continue to the next item.
                // <LIS,i>, i:Term, i+1:Tail:<LIS,i+2>, i+2:Term, i+3:Tail2:<LIS,i+4>, ..., i+2*n:Tailn:'[]'
                let result = '';
                let initialListOfst = get_val(word);
                result += '{' + initialListOfst + '}';
                let finalListOfst = itemOfst;
                let items = '';
                let listOrTail = word;
                let tailOfst;
                while(get_tag(listOrTail) === TAG_LIS) {
                    let headOfst = get_val(listOrTail);
                    if(headOfst === finalListOfst+2) {
                        finalListOfst += 2;
                    }
                    let info = interpret_memory_item(results, headOfst);
                    if(items !== '') {
                        items += ', ';
                    }
                    items += info.string;
                    tailOfst = headOfst+1;
                    listOrTail = results[tailOfst];
                }

                let next;
                if(get_tag(listOrTail) === TAG_CON && lookup_atom('[]') === get_val(listOrTail)) {
                    result = '[' + items + ']';
                    if(tailOfst === finalListOfst+1) {
                        next = tailOfst + 1;
                    } else {
                        next = finalListOfst+1;
                    }
                } else {
                    let info = interpret_memory_item(results, tailOfst);
                    result = '[' + items + '|' + info.string + ']';
                    if(tailOfst === finalListOfst+1) {
                        next = info.nextItemOfst;
                    } else {
                        next = finalListOfst;
                    }
                }

                return {string: result, nextItemOfst: next};
            }
            case TAG_CON: // CONstant: 'a' instead of a/0.
            {
                let internalID = get_val(word);
                let constant = find_atom(internalID);
                let result = '';
                result +=  "'" + constant + "'";
                return {string: result, nextItemOfst: itemOfst+1};
            }
            default:
            {
                return {string: 'unrecognized: ' + word + ' (tag = ' + tag + ', val = ' + get_val(word) + ') at ' + itemOfst,
                    nextItemOfst: itemOfst+1};
            }
        }
    }

    function interpret_memory_structure(results, result, indicator, structureWordOfst, itemOfst) {
        let pair = indicators[indicator];
        let functorID = pair[0];
        result += atable[functorID] + '(';
        let arity = pair[1];
        for(let argOfst = 0;argOfst < arity;argOfst++) {
            let argInfo = interpret_memory_item(results, structureWordOfst + 1 + argOfst);
            if(argOfst > 0) {
                result += ', ';
            }

            if(argInfo.nextItemOfst !== structureWordOfst + 1 + argOfst + 1) {
                throw 'invalid structure words';
            }

            result += argInfo.string;
        }
        result += ')';
        let nextOfst = (structureWordOfst === 0 || structureWordOfst === itemOfst+1) ? itemOfst + arity + 1 : itemOfst + 1;
        return  {string: result, nextItemOfst: nextOfst}
    }

    function traceInstLog0 (opCode) {
        let opName = getOpCodeName(opCode);
        console.log('inst: ' + opName + ";");
    }

    function traceInstLog1 (opCode, arg1) {
        let opName = getOpCodeName(opCode);
        console.log('inst: ' + opName + " " + arg1 + ";");
    }

    function traceInstLog2 (opCode, arg1, arg2) {
        let opName = getOpCodeName(opCode);
        console.log('inst: ' + opName + " " + arg1 + ", " + arg2 + ";");
    }

    function traceInstLog3 (opCode, arg1, arg2, arg3) {
        let opName = getOpCodeName(opCode);
        console.log('inst: ' + opName + " " + arg1 + ", " + arg2 + ", " + arg3 + ";");
    }

    function traceStoreZero (addr) {
        console.log ('warning: storing 0 to address ' + addr);
    }
    function traceDerefZero () {
        console.log ('warning: dereferencing address 0.');
    }
    function traceStoreTrailToReg() {
        console.log ('warning: storing $minTrail address to $reg 1.')
    }

    const READ = 0;
    const WRITE = 1;
    const TAG_REF = 0; // 0x00000000
    const TAG_STR = 1; // 0x08000000
    const TAG_LIS = 2; // 0x10000000
    const TAG_INT = 3; // 0x18000000
    const TAG_CON = 4; // 0x20000000 // was TAG_ATM.
    const TAG_FLT = 5; // 0x28000000
    const TAG_PRE = 6; // 0x30000000
    const WORD_BITS = 27;
    const TAG_MASK = 7;

    function add_tag(value) {
        return value ^ (TAG_STR << WORD_BITS)
    }

    function get_tag(p)
    {
        // >>> is unsigned-right-shift. Nice.
        return (p >>> WORD_BITS) & TAG_MASK;
    }
    function get_val(p)
    {
        return p & ((1 << WORD_BITS)-1);
    }

</script>
</head>
<body>
<div id="tests">
    <ul>
        <li><button onclick="test_query_4_4_a();">test_query_4_4_a</button></li>
        <li><button onclick="test_query_5_4();">test_query_5_4</button></li>
        <li><button onclick="test_query_5_7();">test_query_5_7</button></li>
    </ul>
</div>
<div id="display">
    <div id="testName">

    </div>
    <br>
    <br>
    <div id="result">

    </div>
    <br>
    <br>
    <div id="resultInterpretationRegisters">

    </div>
    <br>
    <br>
    <div id="resultInterpretationHeap">

    </div>
</div>
</body>
</html>
